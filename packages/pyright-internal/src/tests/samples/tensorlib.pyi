# This sample represents a typical tensor library that might use the
# "Shape" refinement. It is used by other test cases.

# This sample defines the basic classes found in a typical tensor
# library. It's meant to test refinement types for tensor shape
# validation.

from typing import Literal, overload
from typing_extensions import IntTupleValue, Shape

class Size(tuple[int, ...]):
    @classmethod
    def __type_metadata__(cls, predicate: str) -> Shape: ...
    def __getitem__(self: Size @ "o", key: int @ "i") -> int @ "index(o, i)": ...  # pyright: ignore[reportIncompatibleMethodOverride]
    def elem_count(self: Size @ "o") -> int @ "len(o)": ...

class Tensor:
    def __init__(self, value) -> None: ...
    @classmethod
    def __type_metadata__(cls, predicate: str) -> Shape: ...
    @property
    def shape(self: Tensor @ "o") -> Size @ "o": ...
    def transpose(self: Tensor @ "o", dim0: int @ "a", dim1: int @ "b") -> Tensor @ "swap(o, a, b)": ...
    def view(self: Tensor @ "o", *args: *(tuple[int, ...] @ IntTupleValue("t"))) -> Tensor @ "reshape(o, t)": ...
    def cos(self: Tensor @ "o") -> Tensor @ "o": ...
    def sin(self: Tensor @ "o") -> Tensor @ "o": ...
    def add(self: Tensor @ "o", input: Tensor @ "i") -> Tensor @ "broadcast(o, i)": ...
    def __add__(self: Tensor @ "o", input: Tensor @ "i") -> Tensor @ "broadcast(o, i)": ...
    def sub(self: Tensor @ "o", input: Tensor @ "i") -> Tensor @ "broadcast(o, i)": ...
    def __sub__(self: Tensor @ "o", input: Tensor @ "i") -> Tensor @ "broadcast(o, i)": ...
    def pow(self: Tensor @ "o", exp: float) -> Tensor @ "o": ...
    def __pow__(self: Tensor @ "o", exp: float) -> Tensor @ "o": ...

@overload
def cat(
    tensors: tuple[Tensor @ "t1", Tensor @ "t2"],
    dim: int @ "d" = 0,
    *,
    out: Tensor @ "o if o == concat(t1, t2, d)" | None = ...,
) -> Tensor @ "concat(t1, t2, d)": ...
@overload
def cat(
    tensors: tuple[Tensor @ "t1", Tensor @ "t2", Tensor @ "t3"],
    dim: int @ "d" = 0,
    *,
    out: Tensor @ "o if o == concat(concat(t1, t2, d), t3, d)" | None = ...,
) -> Tensor @ "concat(concat(t1, t2, d), t3, d)": ...
@overload
def cat(
    tensors: tuple[Tensor @ "t1", Tensor @ "t2", Tensor @ "t3", Tensor @ "t4"],
    dim: int @ "d" = 0,
    *,
    out: Tensor @ "o if o == concat(concat(concat(t1, t2, d), t3, d), t4, d)" | None = ...,
) -> Tensor @ "concat(concat(concat(t1, t2, d), t3, d), t4, d)": ...
@overload
def cat(tensors: tuple[Tensor, ...], dim: int = 0, *, out: Tensor | None = ...) -> Tensor: ...
def conv2d(
    input: Tensor @ "n, c_in, h_in, w_in",
    weight: Tensor @ "c_out, gr, k0, k1 if gr == c_in // g",
    bias: Tensor @ "c_out," | None = None,
    stride: int @ "s0" @ "s1" | tuple[int @ "s0", int @ "s1"] = 1,
    padding: int @ "p0" @ "p1" | tuple[int @ "p0", int @ "p1"] = 0,
    dilation: int @ "d0" @ "d1" | tuple[int @ "d0", int @ "d1"] = 1,
    groups: int @ "g" = 1,
) -> (
    Tensor @ "n, c_out, (h_in + 2 * p0 - d0 * (k0 - 1) - 1) // s0 + 1, (w_in + 2 * p1 - d1 * (k1 - 1) - 1) // s1 + 1"
): ...
def index_select(
    input: Tensor @ "o", dim: int @ "i if index(o, i) == _", index: Tensor @ "x,"
) -> Tensor @ "splice(o, i, 1, (x,))": ...
def linspace(
    start: float, end: float, steps: int @ "x if x > 0", *, out: Tensor @ "x, " | None = None
) -> Tensor @ "x, ": ...
def logspace(
    start: float, end: float, steps: int @ "x if x > 0", *, out: Tensor @ "x, " | None = None
) -> Tensor @ "x, ": ...
def permute(
    input: Tensor @ "o", dims: tuple[int, ...] @ IntTupleValue("d if permute(o, d) == _")
) -> Tensor @ "permute(o, d)": ...
def randn(*args: *(tuple[int, ...] @ Shape("o"))) -> Tensor @ "o": ...
def sqrt(input: Tensor @ "o") -> Tensor @ "o": ...
@overload
def squeeze(input: Tensor @ "o", dim: int @ "i if index(o, i) == 1") -> Tensor @ "splice(o, i, 1, ())": ...
@overload
def squeeze(input: Tensor @ "o", dim: int @ "i if index(o, i) != 1") -> Tensor @ "o": ...
@overload
def squeeze(input: Tensor, dim: tuple[int, ...] | None = None) -> Tensor: ...
@overload
def sum(input: Tensor @ "o", *, dim: None = None, keepdim: bool = False) -> Tensor @ "(1, )": ...
@overload
def sum(
    input: Tensor @ "o",
    *,
    dim: int @ "d",
    keepdim: Literal[False] = False,
) -> Tensor @ "splice(o, d, 1, ())": ...
@overload
def sum(input: Tensor @ "o", *, dim: int @ "d", keepdim: Literal[True]) -> Tensor @ "splice(o, d, 1, (1, ))": ...
def take(input: Tensor @ "o", index: Tensor @ "x,") -> Tensor @ "x,": ...
@overload
def unsqueeze(input: Tensor @ "o", dim: int @ "d if d >= 0") -> Tensor @ "splice(o, d, 0, (1,))": ...
@overload
def unsqueeze(input: Tensor @ "o", dim: int @ "d if d < 0") -> Tensor @ "splice(o, len(o) + d + 1, 0, (1,))": ...
@overload
def unsqueeze(input: Tensor, dim: int) -> Tensor: ...
